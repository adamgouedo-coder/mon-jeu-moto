<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Moto 3D — Mode Nuit & Voitures Animées</title>
<style>
  :root{ --accent:#ff6600; --dark:#050505; --glass: rgba(255,255,255,0.06); }
  html,body{ height:100%; margin:0; background:#000; font-family:Inter,Arial,Helvetica,sans-serif; color:#fff; }
  #gameContainer{ position:relative; width:100vw; height:100vh; overflow:hidden; }
  canvas{ display:block; }


  /* UI */
  #hud{
    position:absolute; left:18px; top:18px; z-index:50;
    background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.35));
    border: 1px solid rgba(255,255,255,0.06);
    padding:10px 14px; border-radius:12px; backdrop-filter: blur(6px);
  }
  #hud .line{ font-weight:700; margin:4px 0; display:flex; gap:12px; align-items:center; }
  #hud .small{ font-size:13px; font-weight:600; color:#ddd; opacity:.9; }


  /* Game Over / Victory screens */
  .overlay{
    position:absolute; z-index:200; left:50%; top:50%; transform:translate(-50%,-50%);
    min-width:320px; max-width:86vw; padding:28px; border-radius:16px; text-align:center;
    box-shadow: 0 10px 40px rgba(0,0,0,0.7);
    backdrop-filter: blur(4px);
  }
  #startScreen{ display:block; background: linear-gradient(180deg, rgba(0,0,0,0.85), rgba(0,0,0,0.6)); border:3px solid var(--accent); color:#fff; }
  #gameOverScreen{ display:none; background: linear-gradient(180deg, rgba(20,0,0,0.9), rgba(0,0,0,0.7)); border:3px solid #ff3333; color:#fff; }
  .title{ font-size:30px; font-weight:800; color:var(--accent); margin:6px 0 12px 0; }
  .btn{
    display:inline-block; margin:10px 6px; padding:12px 20px; border-radius:10px; cursor:pointer;
    font-weight:800; border:none; color:#111;
  }
  .btn-play{ background: linear-gradient(45deg, #00ff00, #00aa66); }
  .btn-next{ background: linear-gradient(45deg, var(--accent), #ff9900); color:#111; }
  .btn-ghost{ background:transparent; border:1px solid rgba(255,255,255,0.12); color:#fff; }


  /* mobile hint */
  #touchControls{ display:none; position:absolute; right:18px; bottom:18px; z-index:60; gap:8px; }
  .tbtn{ padding:12px 16px; border-radius:10px; background:var(--glass); border:1px solid rgba(255,255,255,0.06); font-weight:700; }


  @media (max-width:720px){
    #touchControls{ display:flex; flex-direction:row; }
    .title{ font-size:20px; }
  }


  /* subtle footer credit */
  #credit{ position:absolute; left:50%; bottom:10px; transform:translateX(-50%); color:rgba(255,255,255,0.12); font-size:12px; z-index:10; }
</style>
</head>
<body>
  <div id="gameContainer">
    <div id="hud">
      <div class="line"><div id="levelLabel">Nuit — Trafic</div></div>
      <div class="line small">Score: <span id="score">0</span> · Distance: <span id="distance">0</span> m</div>
      <div class="line small">Vitesse: <span id="speedLabel">NORMAL</span></div>
    </div>


    <!-- Start screen -->
    <div id="startScreen" class="overlay">
      <div class="title">🏁 BIENVENUE — ROUTE DE NUIT</div>
      <div style="margin-bottom:12px; color:#ddd;">Voitures sur les côtés — phares & lampadaires activés.<br>Contrôles : ← → ou A/D. Sur mobile, utilise les boutons en bas.</div>
      <button id="startBtn" class="btn btn-play">▶️ Lancer la partie</button>
      <button id="muteBtn" class="btn btn-ghost">🔊 Son activé</button>
    </div>


    <!-- Game Over -->
    <div id="gameOverScreen" class="overlay">
      <div class="title" style="color:#ff6666">💥 GAME OVER</div>
      <div style="font-weight:700; font-size:18px; margin-bottom:10px;">Score final: <span id="finalScore">0</span></div>
      <div style="color:#ddd; margin-bottom:12px;">Niveau atteint: <span id="finalLevel">1</span></div>
      <button id="restartBtn" class="btn btn-next">🔄 Recommencer</button>
      <button id="toMenuBtn" class="btn btn-ghost">🏠 Menu</button>
    </div>


    <!-- Touch controls (mobile) -->
    <div id="touchControls">
      <button id="leftTouch" class="tbtn">◀</button>
      <button id="rightTouch" class="tbtn">▶</button>
    </div>


    <div id="credit">made with vibes ⚡</div>
  </div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* ---------------------------
   Jeu : Moto (nuit) + Voitures
   - Moto collée au sol (pas de saut)
   - Voitures spawn uniquement sur les côtés (x ≈ -5 / +5)
   - Phare voitures = SpotLight + Mesh materiél emissif
   - Lampadaires le long de la route
   - Son moteur synthétique (WebAudio) et crash bruit
---------------------------- */


let scene, camera, renderer, clock;
let motorcycle;
let cars = [];      // obstacles (only on sides)
let decor = [];     // lampadaires & trees
let score = 0, distance = 0;
let running = false;
let spawnTimer = 0;


const params = {
  laneX: [ -5.5, 5.5 ],    // side lanes where cars can be
  roadWidth: 12,
  carSpawnInterval: 1.6,  // seconds
  speed: 18,               // world units per second (forward)
  difficulty: 1,
  muted: false
};


// WebAudio synth
let audioCtx = null;
let engineOsc = null;
let engineGain = null;
let crashBuffer = null;


const hud = {
  score: document.getElementById('score'),
  distance: document.getElementById('distance'),
  speedLabel: document.getElementById('speedLabel'),
  startScreen: document.getElementById('startScreen'),
  startBtn: document.getElementById('startBtn'),
  muteBtn: document.getElementById('muteBtn'),
  gameOverScreen: document.getElementById('gameOverScreen'),
  finalScore: document.getElementById('finalScore'),
  restartBtn: document.getElementById('restartBtn'),
  toMenuBtn: document.getElementById('toMenuBtn')
};


// Controls
const keys = {};
let touchLeft = false, touchRight = false;


/* ---------------- init three ---------------- */
function initThree(){
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x000722, 20, 300);


  camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
  camera.position.set(0, 6, 12);
  camera.lookAt(0, 1.5, -20);


  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(innerWidth, innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  document.getElementById('gameContainer').appendChild(renderer.domElement);


  clock = new THREE.Clock();
}


/* ---------------- lighting & environment ---------------- */
function setupEnvironment(){
  // subtle ambient night
  const amb = new THREE.HemisphereLight(0x666688, 0x000022, 0.6);
  scene.add(amb);


  const moon = new THREE.DirectionalLight(0xbfdfff, 0.35);
  moon.position.set(-20, 40, 30);
  moon.castShadow = false;
  scene.add(moon);


  // road (long plane)
  const roadMat = new THREE.MeshPhongMaterial({ color: 0x222233 });
  for(let i=0;i<60;i++){
    const p = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), roadMat);
    p.rotation.x = -Math.PI/2;
    p.position.z = -i * 20;
    p.receiveShadow = true;
    scene.add(p);
  }


  // center dashed line
  for(let i=0;i<120;i+=2){
    const stripe = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 6), new THREE.MeshBasicMaterial({ color:0xfff3b0 }));
    stripe.rotation.x = -Math.PI/2;
    stripe.position.set(0, 0.02, -i*10);
    scene.add(stripe);
  }


  // lampadaires along the road every ~40 units
  for(let i=0;i<40;i++){
    const z = -i * 40 - 10;
    createLampPost(-8, z);
    createLampPost(8, z);
  }


  // distant city glow (simple)
  const city = new THREE.Mesh(new THREE.PlaneGeometry(200, 100), new THREE.MeshBasicMaterial({ color: 0x110022, side: THREE.DoubleSide, transparent:true, opacity:0.12 }));
  city.rotation.x = -Math.PI/2;
  city.position.set(0, -30, -800);
  scene.add(city);
}


/* ------------- motorcycle (improved) --------------- */
function createMotorcycle(){
  if(motorcycle) scene.remove(motorcycle);
  motorcycle = new THREE.Group();


  // chassis
  const chassis = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.35,2.4), new THREE.MeshStandardMaterial({ color:0xff5500, metalness:0.2, roughness:0.4 }));
  chassis.position.set(0, 0.9, 0);
  chassis.castShadow = true;
  motorcycle.add(chassis);


  // seat
  const seat = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.2,0.9), new THREE.MeshStandardMaterial({ color:0x222222 }));
  seat.position.set(0, 1.05, -0.2); seat.castShadow = true; motorcycle.add(seat);


  // realistic wheels (tire + rim)
  const tireMat = new THREE.MeshStandardMaterial({ color:0x111111, metalness:0.1, roughness:0.8 });
  const rimMat = new THREE.MeshStandardMaterial({ color:0x222222, metalness:0.8, roughness:0.25 });


  const wheelGeometry = new THREE.TorusGeometry(0.55, 0.18, 16, 40);
  const frontTire = new THREE.Mesh(wheelGeometry, tireMat);
  frontTire.rotation.x = Math.PI/2; frontTire.position.set(0, 0.62, -1.1); frontTire.castShadow = true;
  motorcycle.add(frontTire);


  const rearTire = frontTire.clone(); rearTire.position.set(0, 0.62, 1.1); motorcycle.add(rearTire);


  // rim-ish center (visual)
  const rimGeo = new THREE.CylinderGeometry(0.18,0.18,0.2, 16);
  const rim = new THREE.Mesh(rimGeo, rimMat); rim.rotation.z = Math.PI/2; rim.position.set(0,0.62,-1.1); motorcycle.add(rim);
  const rim2 = rim.clone(); rim2.position.set(0,0.62,1.1); motorcycle.add(rim2);


  // handlebar
  const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,1.2), new THREE.MeshStandardMaterial({ color:0x999999 }));
  bar.rotation.z = Math.PI/2; bar.position.set(0, 1.25, -1.15); bar.castShadow = true; motorcycle.add(bar);


  // headlight (emissive)
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.14,12,8), new THREE.MeshStandardMaterial({ color:0xfff1cc, emissive:0x333322, emissiveIntensity:0.5 }));
  head.position.set(0, 1.05, -1.55); motorcycle.add(head);


  // small exhaust
  const exhaust = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,0.6), new THREE.MeshStandardMaterial({ color:0x222 }));
  exhaust.rotation.z = Math.PI/2; exhaust.position.set(0.5, 0.85, 0.95); motorcycle.add(exhaust);


  // initial placement
  motorcycle.position.set(0, 0, 6);
  scene.add(motorcycle);
}


/* -------------- Lamp posts -------------- */
function createLampPost(x, z){
  const post = new THREE.Group();
  const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.07,0.09,4), new THREE.MeshStandardMaterial({ color:0x444444 }));
  pole.position.y = 2;
  post.add(pole);


  // lamp head
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.25,10,8), new THREE.MeshStandardMaterial({ color:0xfff0cc, emissive:0xffeebb, emissiveIntensity:0.8 }));
  head.position.set(0, 3.8, 0);
  post.add(head);


  // light
  const light = new THREE.PointLight(0xfff0bb, 0.9, 18, 2);
  light.position.set(0, 3.8, 0);
  light.castShadow = false;
  post.add(light);


  post.position.set(x, 0, z);
  post.traverse(c => c.castShadow = true);
  decor.push(post);
  scene.add(post);
}


/* ------------- Cars (obstacles) -------------- */
/* Cars will be simple groups that move forward (increase z). 
   They spawn at negative z and move toward camera.
   They will be placed only in side lanes (params.laneX). */


function createCar(sideIndex, z){
  // sideIndex : 0 => left lane, 1 => right lane
  const laneX = params.laneX[sideIndex];
  const x = laneX + (Math.random()*0.8 - 0.4); // small jitter
  const car = new THREE.Group();


  // main body
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.0,0.8,4.0), new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random()*0.2+0.55,0.6,0.45), metalness:0.4, roughness:0.3 }));
  body.position.y = 0.5; body.castShadow = true; car.add(body);


  // cabin
  const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.4,0.6,1.6), new THREE.MeshStandardMaterial({ color:0x112233, metalness:0.1, roughness:0.2 }));
  cabin.position.set(0, 1.0, -0.2); car.add(cabin);


  // wheels
  const wheelGeo = new THREE.CylinderGeometry(0.35,0.35,0.3, 14);
  const wheelMat = new THREE.MeshStandardMaterial({ color:0x111111 });
  for(let dx of [-0.75,0.75]){
    for(let dz of [-1.5,1.5]){
      const w = new THREE.Mesh(wheelGeo, wheelMat); w.rotation.z = Math.PI/2; w.position.set(dx, 0.32, dz); car.add(w);
    }
  }


  // headlight mesh (emissive)
  const headL = new THREE.Mesh(new THREE.BoxGeometry(0.22,0.12,0.06), new THREE.MeshStandardMaterial({ color:0xffffcc, emissive:0xffffaa, emissiveIntensity:0.9 }));
  const headR = headL.clone();
  headL.position.set(-0.45, 0.62, -2.05); headR.position.set(0.45, 0.62, -2.05);
  car.add(headL); car.add(headR);


  // headlight spotlight (points forward toward the road center)
  const spot = new THREE.SpotLight(0xfff6d0, 1.2, 120, Math.PI/8, 0.4, 1.5);
  spot.position.set(0, 0.9, -2.05);
  spot.target.position.set(0, 0.5, -6);
  spot.castShadow = false;
  car.add(spot);
  car.add(spot.target);


  // set car position
  car.position.set(x, 0, z);
  car.userData = {
    speed: 16 + Math.random()*6,         // their forward speed (toward camera)
    sideIndex: sideIndex,
    alive: true,
    spotlight: spot
  };
  car.traverse(m => { if(m.isMesh) m.castShadow = true; });
  scene.add(car);
  cars.push(car);
}


/* ------------- Spawner -------------- */
function spawnCars(delta){
  spawnTimer += delta;
  if(spawnTimer >= params.carSpawnInterval / params.difficulty){
    spawnTimer = 0;
    // spawn on left or right randomly (but ensure not too many clustering)
    const side = Math.random() < 0.5 ? 0 : 1;
    // spawn far ahead (z negative)
    const z = -200 - Math.random()*200;
    createCar(side, z);
  }


  // occasionally increase difficulty
  if(Math.random() < 0.01 * delta){
    params.difficulty = Math.min(2.2, params.difficulty + 0.02);
  }
}


/* ------------- Collisions -------------- */
function checkCollisions(){
  // Simple boxes/circle overlap: compare x and z with thresholds
  for(let i=cars.length-1;i>=0;i--){
    const car = cars[i];
    if(!car.userData.alive) continue;
    const dx = motorcycle.position.x - car.position.x;
    const dz = motorcycle.position.z - car.position.z;
    // collision if close enough (car size ~2x4), motorcycle ~1
    const collideX = Math.abs(dx) < 1.2 + 0.8;
    const collideZ = Math.abs(dz) < 1.8 + 0.8;
    if(collideX && collideZ){
      // crash!
      car.userData.alive = false;
      triggerCrash(car);
      return true;
    }
  }
  return false;
}


/* ------------- Crash & Game Over -------------- */
function triggerCrash(car){
  // stop running, play crash sound, show screen
  running = false;
  // play crash sound
  playCrashSound();


  // show game over overlay
  hud.finalScore.textContent = Math.floor(score);
  hud.gameOverScreen.style.display = 'block';
  hud.startScreen.style.display = 'none';
  // small camera shake
  cameraShake(0.6, 800);
}


/* ------------- Camera shake -------------- */
let shakeTill = 0; let shakeAmp = 0;
function cameraShake(amp, ms){
  shakeAmp = amp; shakeTill = performance.now() + ms;
}


/* ------------- Audio (WebAudio) -------------- */
async function setupAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();


  // engine oscillator (sawtooth-like via multiple oscillators)
  engineGain = audioCtx.createGain();
  engineGain.gain.value = 0; // start muted
  engineGain.connect(audioCtx.destination);


  // base oscillator
  engineOsc = audioCtx.createOscillator();
  engineOsc.type = 'sawtooth';
  engineOsc.frequency.value = 80; // low rumble
  engineOsc.connect(engineGain);


  // add subtle noise using script processor -> create buffer-based noise
  const bufferSize = 2 * audioCtx.sampleRate;
  const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const output = noiseBuffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) output[i] = (Math.random() * 2 - 1) * 0.002;
  const noiseSource = audioCtx.createBufferSource();
  noiseSource.buffer = noiseBuffer;
  noiseSource.loop = true;
  const noiseGain = audioCtx.createGain(); noiseGain.gain.value = 0.02;
  noiseSource.connect(noiseGain);
  noiseGain.connect(engineGain);


  // start
  engineOsc.start();
  noiseSource.start();


  // build crashBuffer: short noise burst
  crashBuffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 1.0, audioCtx.sampleRate);
  const cb = crashBuffer.getChannelData(0);
  for(let i=0;i<cb.length;i++){
    // decaying noise
    const t = i / cb.length;
    cb[i] = (Math.random()*2 -1) * (1 - t) * (Math.exp(-3*t));
  }
}


/* play crash */
function playCrashSound(){
  if(!audioCtx) return;
  const s = audioCtx.createBufferSource();
  s.buffer = crashBuffer;
  const g = audioCtx.createGain(); g.gain.value = 0.9;
  s.connect(g); g.connect(audioCtx.destination);
  s.start();
  // stop engine
  if(engineGain) engineGain.gain.linearRampToValueAtTime(0.0001, audioCtx.currentTime + 0.05);
}


/* set engine volume & timbre based on speed */
function updateEngineSound(targetStrength){
  if(!audioCtx || !engineGain) return;
  const now = audioCtx.currentTime;
  engineGain.gain.cancelScheduledValues(now);
  engineGain.gain.linearRampToValueAtTime(targetStrength, now + 0.08);
  // vary oscillator frequency slightly for more life
  engineOsc.frequency.setTargetAtTime(80 + targetStrength*100, now, 0.1);
}


/* ---------------- main loop ---------------- */
function resetGame(){
  // cleanup cars & decor
  cars.forEach(c => scene.remove(c));
  cars = [];
  decor.forEach(d => {}); // lamp posts remain
  score = 0; distance = 0; spawnTimer = 0; params.difficulty = 1;
  hud.score.textContent = '0';
  hud.distance.textContent = '0';
  running = true;
  hud.gameOverScreen.style.display = 'none';
  hud.startScreen.style.display = 'none';
  // reset engine
  if(audioCtx) updateEngineSound(0.35);
  // clear old cars
  for(let i=0;i<0;i++);
}


function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta(); // seconds
  if(running){
    // move world -> actually we move cars and decor towards camera
    const forward = params.speed * dt * (1 + params.difficulty*0.15);
    distance += forward * 0.3;
    score += Math.floor(forward * 0.5);
    hud.score.textContent = Math.floor(score);
    hud.distance.textContent = Math.floor(distance);


    // update cars
    for(let i=cars.length-1;i>=0;i--){
      const car = cars[i];
      // cars have their own speed; they move toward camera: z += carSpeed * dt
      const carSpeed = car.userData.speed * (0.9 + Math.random()*0.2);
      car.position.z += carSpeed * dt;
      // slightly sway headlights target to give life
      car.userData.spotlight.target.position.set(car.position.x*0.05, 0.5, car.position.z - 6);


      // remove if past
      if(car.position.z > 30){
        // remove
        scene.remove(car);
        cars.splice(i,1);
        continue;
      }
    }


    // spawn
    spawnCars(dt);


    // check collisions
    if(checkCollisions()){
      // triggered crash inside function
    }


    // small camera follow to player's x
    camera.position.x += (motorcycle.position.x - camera.position.x) * 0.06;
    // camera bob based on speed
    camera.position.y += (6 - camera.position.y) * 0.02;


    // per-frame engine sound update based on difficulty/speed
    if(audioCtx) updateEngineSound(0.2 + Math.min(1, params.difficulty*0.4));


    // camera shake
    if(performance.now() < shakeTill){
      const s = (Math.random()*2-1)*shakeAmp;
      camera.position.x += s * 0.02;
      camera.position.y += s * 0.01;
    } else {
      shakeAmp = 0;
    }
  }


  // update motorcycle position from controls (no flying)
  const laneLimit = params.roadWidth/2 - 1.2;
  let move = 0;
  if(keys['ArrowLeft'] || keys['a'] || touchLeft) move = -1;
  if(keys['ArrowRight'] || keys['d'] || touchRight) move = 1;
  motorcycle.position.x = THREE.MathUtils.clamp(motorcycle.position.x + move * 8 * clock.getDelta(), -laneLimit, laneLimit);
  // slight lean
  motorcycle.rotation.z = THREE.MathUtils.lerp(motorcycle.rotation.z, -move*0.15, 0.18);


  renderer.render(scene, camera);
}


/* ----------------- UI & events ----------------- */
function bindUI(){
  hud.startBtn.onclick = async () => {
    // resume audio context on user gesture
    await setupAudio();
    if(audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();
    hud.startScreen.style.display = 'none';
    resetGame();
    updateEngineSound(0.35);
  };
  hud.muteBtn.onclick = () => {
    params.muted = !params.muted;
    hud.muteBtn.textContent = params.muted ? '🔇 Muet' : '🔊 Son activé';
    if(audioCtx) audioCtx.resume(); // ensure ready
    // apply gain mute
    if(engineGain) engineGain.gain.value = params.muted ? 0 : 0.35;
  };
  hud.restartBtn.onclick = async () => {
    // restart in place
    hud.gameOverScreen.style.display = 'none';
    // reset position of camera & motorcycle
    motorcycle.position.set(0,0,6);
    camera.position.set(0,6,12);
    await setupAudio();
    resetGame();
    running = true;
  };
  hud.toMenuBtn.onclick = () => {
    hud.gameOverScreen.style.display = 'none';
    hud.startScreen.style.display = 'block';
    if(engineGain) engineGain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
    running = false;
  };


  // touch controls
  document.getElementById('leftTouch').addEventListener('pointerdown', ()=> touchLeft = true);
  document.getElementById('leftTouch').addEventListener('pointerup', ()=> touchLeft = false);
  document.getElementById('rightTouch').addEventListener('pointerdown', ()=> touchRight = true);
  document.getElementById('rightTouch').addEventListener('pointerup', ()=> touchRight = false);


  window.addEventListener('keydown', e => keys[e.key] = true);
  window.addEventListener('keyup', e => keys[e.key] = false);
  window.addEventListener('resize', () => {
    camera.aspect = innerWidth/innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
}


/* ----------------- Triggered effects ----------------- */
function triggerCarImpactVisual(car){
  // flash the headlight briefly and tint the car
  if(car && car.userData && car.userData.spotlight){
    const s = car.userData.spotlight;
    // temporarily increase intensity
    let original = s.intensity;
    s.intensity = original * 2.5;
    setTimeout(()=> { if(s) s.intensity = original; }, 200);
  }
}


/* ----------------- play crash AND visual ---------------- */
function triggerCrash(car){
  triggerCarImpactVisual(car);
  // play crash & stop engine
  playCrashSound();
  running = false;
  hud.finalScore.textContent = Math.floor(score);
  hud.gameOverScreen.style.display = 'block';
  // gentle camera shake
  cameraShake(1.2, 650);
}


/* ----------------- Boot sequence ---------------- */
async function boot(){
  initThree();
  setupEnvironment();
  createMotorcycle();
  bindUI();
  await setupAudio();
  clock.start = performance.now();
  clock.getDelta(); // init
  animate();
}


// spawn logic helper uses createCar defined above
function spawnCars(dt){
  spawnCarsCalled = true;
  spawnCars_last(dt);
}


// I use a wrapper to avoid hoisting confusion
let spawnCars_last = spawnCarsImpl;
function spawnCarsImpl(dt){
  spawnCars = spawnCarsImpl; // ensure future calls go here
  spawnCarsImpl(dt);
}


/* fix recursive wrapper implementation properly */
function spawnCarsImpl(dt){
  // actual spawner (rewritten here)
  spawnTimer += dt;
  if(spawnTimer >= params.carSpawnInterval / params.difficulty){
    spawnTimer = 0;
    // choose side with some simple bias to avoid clusters
    const side = Math.random() < 0.5 ? 0 : 1;
    createCar(side, -220 - Math.random()*240);
  }
  // small difficulty ramp
  if(Math.random() < 0.01 * dt) params.difficulty = Math.min(2.4, params.difficulty + 0.02);
}


/* override earlier spawnCars placeholder with proper function */
spawnCars = spawnCarsImpl;


/* assign spawnTimer defined earlier (we used) */
spawnTimer = 0;


/* ----------------- start ----------------- */
boot();


/* A simpler crash-player (in case crashBuffer not ready) */
function playCrashSound(){
  if(audioCtx && crashBuffer){
    const s = audioCtx.createBufferSource();
    s.buffer = crashBuffer;
    const g = audioCtx.createGain(); g.gain.value = 1.0;
    s.connect(g); g.connect(audioCtx.destination);
    s.start();
    // fade engine out
    if(engineGain) engineGain.gain.linearRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
    return;
  }
  // fallback: quick oscillator thud
  if(audioCtx){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain(); g.gain.value = 0.5;
    o.type = 'sine'; o.frequency.value = 60;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
    o.stop(audioCtx.currentTime + 0.27);
  }
}


/* end of script */
</script>
</body>
</html>